\newpage

\section{Recuperação de Versões e Versionamento}

\subsection{Visualização do Histórico de Commits}

O histórico de commits permite acompanhar todas as alterações feitas no projeto, quem realizou cada mudança e quando. Para visualizar o histórico completo, utilize:

\begin{lstlisting}[style=shellstyle]
git log
\end{lstlisting}

No GitHub, acesse a aba Commits do repositório para ver o histórico online, incluindo autor, data e mensagem de cada commit.

\subsection{Recuperação de Arquivos ou Versões Anteriores}

Se for necessário restaurar um arquivo (caso ele tenha sido deletado, por exemplo), utilize:

\begin{lstlisting}[style=shellstyle]
git checkout <hash-do-commit> -- <nome-do-arquivo>
\end{lstlisting}

Caso seja necessário restaurar todo o projeto para um estado anterior, utilize:

\begin{lstlisting}[style=shellstyle]
git checkout <hash-do-commit>
\end{lstlisting}

Nesse caso, tenha atenção: ao fazer isso, o Git colocará o repositório em um estado chamado \textbf{detached HEAD}. Isso significa que você estará apenas visitando um commit antigo, e não estará mais no seu branch atual (por exemplo, \texttt{main} ou \texttt{develop}).  

Se o seu objetivo for apenas consultar o estado do projeto ou recuperar arquivos antigos, isso não é um problema. No entanto, se você fizer alterações e criar novos commits nesse estado, eles não estarão vinculados a nenhum branch e poderão ser perdidos ao trocar de branch.  

Se você quiser apenas olhar um commit antigo, depois de terminar, basta voltar para o seu branch principal com:

\begin{lstlisting}[style=shellstyle]
git checkout main
\end{lstlisting}

Por outro lado, se o objetivo for continuar trabalhando a partir de um commit antigo, o recomendado é criar um novo branch antes de fazer alterações. Isso garante que seus novos commits fiquem salvos com segurança:

\begin{lstlisting}[style=shellstyle]
git checkout -b meu-novo-branch <hash-do-commit>
\end{lstlisting}

Dessa forma, você cria um branch começando do commit escolhido e evita problemas com o modo detached HEAD.  

\subsection{Reversão de Commits (Undo/Revert/Reset)}

Para desfazer um commit que já foi enviado ao repositório remoto (usando \texttt{git push}), utilize:

\begin{lstlisting}[style=shellstyle]
git revert <hash-do-commit>
\end{lstlisting}

Se o commit ainda não foi enviado ao remoto, pode-se usar:

\begin{lstlisting}[style=shellstyle]
git reset --hard <hash-do-commit>
\end{lstlisting}

No GitHub, a reversão pode ser feita manualmente criando um novo commit que desfaz as alterações indesejadas.

\subsection{Comparação entre Versões (Diff)}

Para comparar as diferenças entre dois commits, utilize:

\begin{lstlisting}[style=shellstyle]
git diff <hash1> <hash2>
\end{lstlisting}

No GitHub, selecione dois commits ou branches e use a aba Compare para visualizar as diferenças entre eles.

\subsection{Criação de Tags e Releases}

Tags marcam pontos importantes no histórico, como versões estáveis. Para criar uma tag:

\begin{lstlisting}[style=shellstyle]
git tag -a v1.0 -m "Versão 1.0"
git push origin v1.0
\end{lstlisting}

No GitHub, utilize a aba Releases para criar e gerenciar versões do projeto.

\subsection{Uso de Branches para Versionamento Seguro}

Branches permitem desenvolver novas funcionalidades ou corrigir erros sem afetar o código principal. Para criar um branch:

\begin{lstlisting}[style=shellstyle]
git checkout -b nome-do-branch
\end{lstlisting}

No GitHub, branches são facilmente visualizados e gerenciados na interface do repositório.

\subsection{Auditoria e Rastreabilidade (Blame, Log Detalhado)}

Para identificar quem modificou cada linha de um arquivo, utilize:

\begin{lstlisting}[style=shellstyle]
git blame <nome-do-arquivo>
\end{lstlisting}

O comando \texttt{git log} também pode ser usado com filtros para auditoria detalhada:

\begin{lstlisting}[style=shellstyle]
git log -p <nome-do-arquivo>
\end{lstlisting}

No GitHub, use a opção Blame na visualização de arquivos para